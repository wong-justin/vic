vic depends on ffmpeg and chafa

vic makes ffmpeg calls, assuming ffmpeg is on $PATH:
- main::get_ffprobe_video_metadata() calls `ffprobe` (a sibling of ffmpeg) to get video dimensions and framerate
- main::FrameIterator calls ffmpeg to decode a video file into rgb bytes
- main::main() calls ffmpeg to cut the video into segments (if any segments were made)

calling ffmpeg process on $PATH seemed easier than trying to link ffmpeg libraries
one less build step
not to mention potential license conflicts
ffmpeg performance still seems fine
hopefully there's no downsides

___
chafa is a dynamically linked C library, meaning it already needs to be installed on the user's system. the chafa binary is not needed here, but rather the development libraries and header files.
nothing in place to guarantee/check specific chafa versions; i just went with the latest chafa version at the time, and hopefully it will work for everyone

chafa-sys/ is a sub-crate (?) for creating rust bindings to chafa's C code.
chafa-sys/build.rs has a lot of comments from me figuring out the expected setup
chafa-sys/build.rs::build_dynamic() is the least-boilerplate part of the bindings build; just calling `clang -I chafastuff`, really
everything else in chafa-sys is just boilerplate; lib.rs for a couple tests, wrapper.h just needs to exist for clang i think, and bindgen crate included in Cargo.toml
bindgen creates bindings file at target/debug/build/chafa-sys-abc123something/out/bindings.rs
there's a lot of unused code there, like functions i will never need like `g_get_user_state_dir`, but oh well
i think i can trim the bindings by whitelisting only necessary functions

no static builds yet
static builds involve several new challenges, including glib
glib like a third-party stdlib for C, including threading implementations, string handling, etc
glib is chafa's only dependency
building / statically linking glib is nontrivial
investigate alpine musl satic glib build mentioned in comment on issue #1

src/chafa.rs wraps the lowish-level chafa bindings (eg. unsafe chafa_canvas_new() and unsafe chafa_canvas_unref()) into high-level rust structs (eg. Canvas impl new() and drop())
mainly just hiding C pointers and exposing 

___
src/tui.rs is a generic MVU TUI setup
(model, view, update for a text-based UI)
(essentially the elm architecture)

requires functions of type:
init -> result<model, error>
view (model, stderr) -> (draws on stderr, returns nothing)
update (model, event) -> continue/finish/failed

uses crossterm crate for a standardized API for terminal emulator communication

current, naive event loop (currently tick every 16ms):
frequently polling the terminal for events like keypresses or resizes 
responding to any events received
drawing new frames when appropriate (like ~33ms for 30fps videos) (or after a keypress)
no multithreaded/async event loop yet

all TUI output is written to stderr on the alternate tty buffer
(stdout is reserved for potential messages after app shutdown, i.e. `vic video.mp4 --dry-run`)

___
src/main.rs::FrameIterator is where ffmpeg and chafa meet
chafa is initialized with config like input and output size
each frame, ffmpeg decodes video into rgb bytes
chafa takes rgb bytes and returns a string of ansi colors and unicode blocks, like  "[0m[38;2;254;0;0mâ–ˆ[0m", that will be sent to the terminal

src/main.rs::Model contains app state
including config like video dimensions
and also state like current frame number and the list of timestamps (called markers)

src/main.rs::update() is a big match statement handling events and keypresses

keypresses so far are just for moving to different parts of the video and making/deleting markers

___
demo is scripted in Makefile::demo
uses a neovim :terminal session and some lua to show keypresses, taken from the Showkeys plugin
then screencap with something like obs, probably uvx obs-cli

to get a reproducible static image demo, consider
```
vic ~/test/test.mp4 2>&1 | tee ~/test/vicscreenoutput
# print 2500 or however many lines of screen output it took to create the desired screen
cat ~/test/vicscreenoutput | head -2500 ; printf '\n\n\n\n\n\n\n\n\n'
```

___
feature ideas:

zoomable scrubber
https://img.ly/blog/designing-a-timeline-for-mobile-video-editing/

rust audio playback?
https://github.com/RustAudio/rodio

UI mockup ideas:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€vâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 segment 2 of 2                   help?

â”Œâ”€â”       
â”‚ â”‚       
â””â”€â”˜       
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  1:30 / 2:45      playing         x1.0
 >â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‹              <
 >  .   ..    |   .   .  .   :  .     <
  * 2:01.521
    2:02.107                       8/10

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


 0:12 / 9:56                    playing
 â–â–â–â–â– â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–
 â–Žâ–Žâ–Ž  â”‚                               ðŸ®‡
 â–”â–”â–”â–”â–” â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”
 segment 3 of 3                   help?

___
lesser priorities:

TODO: use chafa::canvas.print_rows() so i dont have to undo line work

TODO: replace all .ok_or(format!(...)) with .ok_or_else(|| format!(...))
see: https://medium.com/@techhara/rust-tip-and-trick-2-5a92641191f6

TODO: use generic Pathlike P instead of filepath: String
and figure out generic type signatures everywhere

___
misc notes:

- internally, chafa represents each char as 8x8 bitmap.
so a canvas of 1 row of 2 chars has 8x8 internal resolution
see: chafa/internal/chafa-symbols-block.h

- a random data point on my older windows machine, i5 processor:
ffmpeg decoding 60fps 180p video into raw frames into /dev/null takes ~3.5 mins, with 1.5GB/sec throughput, and results in 115GB of raw pixel frame output

- looping read_exact() 30x seems faster than reading ffmpeg output stream into a buffer 30x as large. idk why.

- not sure how to seek backwards except for caching frames/data after reading it

- "Writing more than a pipe bufferâ€™s worth of input to stdin without also reading stdout and stderr at the same time may cause a deadlock."

- maybe framereading process can keep reading as long as possible, while display process will only request frames less frequently. also giving the decoding process a head start and caching first few frames might help it feel smoother

- making a new vec buffer each render call seems nearly as fast as using one permanently assigned vec, surprisingly

- usize is meant for referencing memory locations. so dont use it for typical application properties.

- can't declare Box[] of large size because stack isnt that big.
instead, declare vec[] and then .into_boxed_slice() will avoid initializing on stack

perhaps learn more from:
https://github.com/jart/hiptext/blob/master/src/movie.cc
https://github.com/zmwangx/rust-ffmpeg/blob/master/examples/dump-frames.rs
https://github.com/maxcurzi/tplay/blob/main/src/pipeline/frames.rs
https://gist.github.com/AndreaCatania/2b708750ef62171f51c7038e99676822
https://github.com/oddity-ai/video-rs
https://medium.com/init-deep-dive/rust-video-frame-extraction-speed-comparison-4d33fcc99405
chafa_src/tools/chafa/chafa.c::line2963+ while (is_animation)
libavformat
libavutil

___
PRE-WORK RITUAL
taken from:
https://pgadey.ca/notes/writing-ritual/

- am i cozy?
- do i have water?
- is the source code open?
- do i have a notebook nearby?
- is my phone muted / far away?
- do i have an entry point / is the work log updated?
- did i listen to one of the songs?
https://pgadey.ca/share/present-time.mp3
https://pgadey.ca/share/dwelling.mp3
- did i freewrite/warmup for a couple minutes?

magic project thesis:
??

work log: date, time -- duration. -- entry point -- what got done?
- oct 16, 9:30am -- ?? mins. -- task: work on adding UI thread and processing thread
- ??, next entry point: ??
