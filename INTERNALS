vic depends on ffmpeg and chafa

vic makes ffmpeg calls, assuming ffmpeg is on $PATH:
- main::get_ffprobe_video_metadata() calls `ffprobe` (a sibling of ffmpeg) to get video dimensions and framerate
- main::FrameIterator calls ffmpeg to decode a video file into rgb bytes
- main::main() calls ffmpeg to cut the video into segments (if any segments were made)

calling ffmpeg process on $PATH seemed easier than trying to link ffmpeg libraries
one less build step
not to mention potential license conflicts
ffmpeg performance still seems fine
hopefully there's no downsides

___
builds

the easier way to build is to link chafa dynamically, meaning chafa is already installed on the user's system.
the chafa binary is not needed here, but rather the development libraries and header files.
nothing in place to check specific chafa versions; i just went with the latest chafa version at the time, and hopefully it will work for everyone.

chafa-sys/ is a sub-crate for creating rust bindings to chafa's C code.
  src/chafa.rs is a higher-level Rust-style wrapper for lower-level C-style chafa-sys/bindings.rs 
(eg. unsafe chafa_canvas_new() and unsafe chafa_canvas_unref()) are wrapped in high-level rust structs (eg. Canvas impl new() and drop())
  mainly just hiding C pointers and exposing 
chafa-sys/build.rs::link_dynamic() just calls `clang -I chafastuff`, really
bindgen creates bindings file at target/debug/build/chafa-sys-abc123something/out/bindings.rs,
  aka `concat!(env!("OUT_DIR"), "/bindings.rs")`
  i should make this a cli script tho, since i decided to call bindgen once and commit it to the crate, rather than call bindgen for each build

chafa-sys/wrapper.h just needs to exist for clang, and chafa-sys/lib.rs has a couple tests
there's a lot of functions in bindings.rs that i will never need, like `g_get_user_state_dir`, but oh well
i think i can trim the bindings by whitelisting only necessary functions

static builds involve several new challenges, mostly glib
glib like a third-party stdlib for C, including threading implementations, string handling, etc
glib is chafa's only (external?) dependency
building and/or statically linking glib is nontrivial
thanks to mmulet's comment (https://github.com/wong-justin/vic/issues/1#issuecomment-3658269697),
i was able to build vic on alpine with statically linked chafa and glib.
(and apparently alpine's musl libc is better for static linking than the more common gnu libc)
i needed extra commands to make it work:
apk add musl-dev and gettext-static, appending -lgcc to $RUSTFLAGS, and telling rustc to look for libintl

___
leftover notes for any future work on build.rs:

in dockerfile, to dynamically link alpine libintl:
ENV RUSTFLAGS="-Clink-arg=-lintl"
but we want static linking so we used ENV RUSTFLAGS="-l intl"
a last-resort for dynamic linking at runtime may be:
export LD_LIBRARY_PATH="/path/to/chafa/and/glib/on/my/machine:$LD_LIBRARY_PATH" ./vic
"use a recent version of glib and build using meson. it has better/easier cross-compilation support than autotools."
via https://stackoverflow.com/a/60599485
*-dev C libraries usually contain static .a archives
chafa build step complained about libdevtool2 or something like that, but i ignored by using the flag --without-tools
good: bindgen automates binding creation from C headers
bad: bindgen requires libclang, which I guess is supposed to come with llvm as well
https://rust-lang.github.io/rust-bindgen/requirements.html
helpful reference about how linking object files and libraries works in general: https://stackoverflow.com/a/29728671
sometimes just listing all the .c files is enough to build with `cc`. example: https://github.com/kornelski/mozjpeg-sys/blob/384688f9c23e94ddeb353d414d45ede69768ec08/src/build.rs
  but probs not with glib, because it's more complicated
find . | grep '\.c$' | grep -v -e '/tests/ ' -e 'chafa/tools' -e 'glib/.gitlab-ci' -e 'glib/fuzzing'

println!("cargo:rustc-flags=-l chafa -L /usr/local/lib/chafa");
env::set_var("PKG_CONFIG_ALLOW_SYSTEM_CFLAGS", "1");
env::set_var("LD_LIBRARY_PATH", "./vendor/glib");
println!("cargo:rustc-link-search=./vendor/glib/");
env::set_var("PKG_CONFIG_ALLOW_SYSTEM_CFLAGS", "1");
let source_c_files = std::fs::read_dir("vendor/glib")
    .unwrap()
    .filter_map(|entry| {
        let path = &entry.expect("couldn't unwrap entry inside vendor/").path();
        let pathstr = path.to_str().expect("couldn't convert path to string");
        match (
            path.is_file() &
            path.ends_with(".c") &
            !pathstr.contains("tests/") &
            !pathstr.contains("tools/") &
            !pathstr.contains("fuzzing/")
        ) {
            true => Some(String::from(pathstr)),
            false => None
        }
    });
println!("cargo:rustc-env=AR=ar");
println!("cargo:rustc-env=CC=cmd.exe /C zig cc");
println!("cargo:rustc-env=CC_ENABLE_DEBUG_OUTPUT=1");
maybe try manually compiling into objects, then manually linking/stuffing into archive?
supposed to assemble at get_out_dir()
https://github.com/rust-lang/cc-rs/blob/e6e29d873604a14912fa130f4c568bca5062d18a/src/lib.rs#L1277
a library archive is a bunch of objects in a bucket i guess
cc makes a library archive rather than command-line listing all object files because the command-line may have character limits.
name the library archive "lib{actualname}.a"
println!("cargo:rustc-link-search={}", env::var("OUT_DIR").unwrap());
let bindings = bindgen::Builder::default()
    .header("wrapper.h")
    .clang_arg("-I./vendor/chafa/chafa/")
    .clang_arg("-I./vendor/glib/glib/")
    .generate()
    .expect("Unable to generate bindings");


to compile from C src:

`cc` is an option
tps://docs.rs/cc/latest/cc/#compile-time-requirements

or

cc-rs crate, which handles compiles C on multiple platforms into static archives
75KB? https://crates.io/crates/cc
more established

or

cargo-zigbuild, which uses zig as a great drop-in replacement for a C compiler
35KB? https://crates.io/crates/cargo-zigbuild/0.17.3
new-age but promising

i couldn't get any of these to build glib from source, unfortunately

___
general guide to making a -sys crate:


STEPS TO BUILD A RUST LIB WITH C BINDINGS / WRAP A C LIBRARY

0) the C library needs to be installed, or built and installed.
   apt install chafa wasn't available on my machine, so i had to clone and build chafa.
   to build chafa, i needed to install glib, libdevtools, and a couple other things.
   although the author said: "You could build it --without-tools,
   then you don't need any loaders. The deps will then be glib-2.0 and freetype."
   finally, chafa/autogen.sh, then make, then make install, worked
   note: my chafa version was 1.14.0, and my glib version was 2.56.0

1) a header file must exist in this rust project directory root.
   probs best simply call it wrapper.h, with contents:
   #include <chafa.h>

   (https://rust-lang.github.io/rust-bindgen/tutorial-2.html)

2) in this build script, we need to tell the build tools where to find the libraries.
   there's a few ways to declare these library paths:

   a) write the include/ path args by hand, eg:
      .clang_arg("-I/usr/local/include/chafa")
      ...
      but different build environments will use different paths

   b) use the tool pkg-config to find these paths automatically.
      on the command line, that looks like:
      pkg-config --cflags chafa
      which outputs the string:
      -I/usr/local/include/chafa -I/usr/local/lib...

   c) I couldn't get this to work, but using either
      println!("cargo:rustc-link-search=/path/to/lib")
      or
      println!("cargo:rustc-link-lib=chafa")
      is supposed tell cargo about library locations

   (https://rust-lang.github.io/rust-bindgen/tutorial-3.html)

3) create src/lib.rs with contents:
   include!(concat!(env!("OUT_DIR"), "/bindings.rs"));

   also adding some #![allow(...)] directives to surpress warnings about C-syntax.

   then cargo build should work. bindgen will create a bindings.rs file somewhere deep in target/

4) verify that the layout, size, and alignment of FFI structs
   matches what bindgen thinks they should be, by running cargo test

   (https://rust-lang.github.io/rust-bindgen/tutorial-4.html)

4.5) troubleshoot why some functions are an undefined reference?
     (error while loading shared libraries: no such file or directory libchafa.so.0)
     i guess the linking tools weren't finding /usr/local/lib/libchafa.so.0

     EDIT - my solution was running the simple command `ldconfig`,
     which updates the cache for shared libraries.
     apparently it was not updated since i installed chafa on my system.

5) create safe function wrappers around extern functions
   using Rust idioms and exposing a safe, high-level interface

   (https://doc.rust-lang.org/nomicon/ffi.html)
   (https://medium.com/dwelo-r-d/using-c-libraries-in-rust-13961948c72a)

6) consider whitelisting only necessary functions
   (or blacklisting unused functions)
   to reduce the size of the bindings file

   (https://rust-lang.github.io/rust-bindgen/allowlisting.html)

___
src/tui.rs is a generic MVU TUI setup
(model, view, update for a text-based UI)
(essentially the elm architecture)

requires functions of type:
init -> result<model, error>
view (model, stderr) -> (draws on stderr, returns nothing)
update (model, event) -> continue/finish/failed

uses crossterm crate for a standardized API for terminal emulator communication

current, naive event loop (currently tick every 16ms):
frequently polling the terminal for events like keypresses or resizes 
responding to any events received
drawing new frames when appropriate (like ~33ms for 30fps videos) (or after a keypress)
no multithreaded/async event loop yet

all TUI output is written to stderr on the alternate tty buffer
(stdout is reserved for potential messages after app shutdown, i.e. `vic video.mp4 --dry-run`)

___
src/main.rs::FrameIterator is where ffmpeg and chafa meet
chafa is initialized with config like input and output size
each frame, ffmpeg decodes video into rgb bytes
chafa takes rgb bytes and returns a string of ansi colors and unicode blocks, like  "[0m[38;2;254;0;0mâ–ˆ[0m", that will be sent to the terminal

src/main.rs::Model contains app state
including config like video dimensions
and also state like current frame number and the list of timestamps (called markers)

src/main.rs::update() is a big match statement handling events and keypresses

keypresses so far are just for moving to different parts of the video and making/deleting markers

___
demo is scripted in Makefile::demo
uses a neovim :terminal session and some lua to show keypresses, taken from the Showkeys plugin
then screencap with something like obs, probably uvx obs-cli

to get a reproducible static image demo, consider
```
vic ~/test/test.mp4 2>&1 | tee ~/test/vicscreenoutput
# print 2500 or however many lines of screen output it took to create the desired screen
cat ~/test/vicscreenoutput | head -2500 ; printf '\n\n\n\n\n\n\n\n\n'
```

___
feature ideas:

zoomable scrubber
https://img.ly/blog/designing-a-timeline-for-mobile-video-editing/

rust audio playback?
https://github.com/RustAudio/rodio

UI mockup ideas:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€vâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 segment 2 of 2                   help?

â”Œâ”€â”       
â”‚ â”‚       
â””â”€â”˜       
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  1:30 / 2:45      playing         x1.0
 >â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‹              <
 >  .   ..    |   .   .  .   :  .     <
  * 2:01.521
    2:02.107                       8/10

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


 0:12 / 9:56                    playing
 â–â–â–â–â– â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–
 â–Žâ–Žâ–Ž  â”‚                               ðŸ®‡
 â–”â–”â–”â–”â–” â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”
 segment 3 of 3                   help?

___
lesser priorities:

TODO: use chafa::canvas.print_rows() so i dont have to undo line work

TODO: replace all .ok_or(format!(...)) with .ok_or_else(|| format!(...))
see: https://medium.com/@techhara/rust-tip-and-trick-2-5a92641191f6

TODO: use generic Pathlike P instead of filepath: String
and figure out generic type signatures everywhere

___
misc notes:

- internally, chafa represents each char as 8x8 bitmap.
so a canvas of 1 row of 2 chars has 8x8 internal resolution
see: chafa/internal/chafa-symbols-block.h

- a random data point on my older windows machine, i5 processor:
ffmpeg decoding 60fps 180p video into raw frames into /dev/null takes ~3.5 mins, with 1.5GB/sec throughput, and results in 115GB of raw pixel frame output

- looping read_exact() 30x seems faster than reading ffmpeg output stream into a buffer 30x as large. idk why.

- not sure how to seek backwards except for caching frames/data after reading it

- "Writing more than a pipe bufferâ€™s worth of input to stdin without also reading stdout and stderr at the same time may cause a deadlock."

- maybe framereading process can keep reading as long as possible, while display process will only request frames less frequently. also giving the decoding process a head start and caching first few frames might help it feel smoother

- making a new vec buffer each render call seems nearly as fast as using one permanently assigned vec, surprisingly

- usize is meant for referencing memory locations. so dont use it for typical application properties.

- can't declare Box[] of large size because stack isnt that big.
instead, declare vec[] and then .into_boxed_slice() will avoid initializing on stack

perhaps learn more from:
https://github.com/jart/hiptext/blob/master/src/movie.cc
https://github.com/zmwangx/rust-ffmpeg/blob/master/examples/dump-frames.rs
https://github.com/maxcurzi/tplay/blob/main/src/pipeline/frames.rs
https://gist.github.com/AndreaCatania/2b708750ef62171f51c7038e99676822
https://github.com/oddity-ai/video-rs
https://medium.com/init-deep-dive/rust-video-frame-extraction-speed-comparison-4d33fcc99405
chafa_src/tools/chafa/chafa.c::line2963+ while (is_animation)
libavformat
libavutil

___
PRE-WORK RITUAL
taken from:
https://pgadey.ca/notes/writing-ritual/

- am i cozy?
- do i have water?
- is the source code open?
- do i have a notebook nearby?
- is my phone muted / far away?
- do i have an entry point / is the work log updated?
- did i listen to one of the songs?
https://pgadey.ca/share/present-time.mp3
https://pgadey.ca/share/dwelling.mp3
- did i freewrite/warmup for a couple minutes?

magic project thesis:
??

work log: date, time -- duration. -- entry point -- what got done?
- oct 16, 9:30am -- ?? mins. -- task: work on adding UI thread and processing thread
- ??, next entry point: ??
